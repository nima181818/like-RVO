<!DOCTYPE html>
<html>
<style>
.container{
  width:100vw;
  overflow:scroll;
  border:1px solid red;
  display:flex;
  font-size:58px;
  position:relative;
}
.items{
 padding:0 20px;
  text-align:center;
  border-right:1px solid red;
  flex-shrink:0
}
.greenbar{
  text-align:center;
   background:green;
   top:70px;
   width:100px;
    position:absolute;
	height:5px;
	transition: left 0.2s ease;
}

</style>
<body >
  <canvas width=700 height=700 id="canvas"></canvas>
</body>
<script>
window.onload = function(){

let canvas = document.getElementById('canvas');
canvas.onclick=function(e){
console.log(e.pageX,e.pageY);
movingCircle.avoidforce={
x:0,
y:0
}
change(movingCircle,e);
change(obstacleCircle1,e);
change(obstacleCircle2,e)
change(obstacleCircle3,e)
}
function change(obj,e){
   let cos = (e.pageX - obj.x)/((e.pageX - obj.x)**2+(e.pageY - obj.y)**2)**0.5;
let sin = (e.pageY - obj.y)/((e.pageX - obj.x)**2+(e.pageY - obj.y)**2)**0.5;
 obj.velocity = {
 x:cos*30,
 y: sin*30,
 }
obj.destination = {
  x:e.pageX,
  y:e.pageY
}
}
let context = canvas.getContext("2d");
     context.beginPath();
	id=1;
  class Circle{
     constructor(x,y,r){
	   this.id= ++id
	   this.x = x;
	   this.mass = 2
	   this.y = y;
	   this.r = r;
	   this.inaviodingmode={
	   time:0,
	   start:false,
	   end:true
	   }
	   this.dt = 0.05;
	   this.obstaclearray=[]
	   this.obstaclematrix={
	    x:0,
		y:0
	   }
	   this.avoidforce = {
	   x:0,
	   y:0
	   }
	   this.gravityforce = {
	    x:0,
		y:0
	   }
	   
	   this.velocity = {
	     x:0,
		 y:60
	   }
	   this.destination={
	   x:400,
	   y:400
	   }
	   this.MAX_SEE_AHEAD = 1;
	   this.MAX_AVOID_FORCE =40
	   this.MAX_SPEED = 40
	   this.movingtimer = null
	   this.paint()
	 }
	 injectObstacles(obstacle){
	 this.obstaclearray.push(obstacle)
	 }
     paint(){
	    context.arc(this.x,this.y,this.r,0,2*Math.PI);
	 }
	 motivateForce(){
	this.movingtimer = setInterval(()=>{
	  this.x+= this.dt*this.velocity.x;
	  this.y+= this.dt*this.velocity.y;
	  this.updating();
	  
	  this.updatingcalculateobstaclematrix(this.obstaclearray[0]);
	  this.updatingVelocity();
	  this.updatingDisplacement();
	  this.repaint()
	 },16.6)
	     
	 }
	 
	 //计算最近的距离
	 calculateDistance(obstacle,usemiddle=false){
	 if(!usemiddle){
	  let left = (((this.headpositionleft.x-obstacle.x)**2+(this.headpositionleft.y-obstacle.y)**2))**0.5,
	       right = (((this.headpositionright.x-obstacle.x)**2+(this.headpositionright.y-obstacle.y)**2))**0.5
	   
	   return left<=right?left:right
	 }else{
	    return (((this.headposition.x-obstacle.x)**2+(this.headposition.y-obstacle.y)**2))**0.5
	 }
	  
	 }
	 //计算最近的障碍物
	 findMostcloseobstacle(){
	  let obstacle=this.obstaclearray[0]
	for(let j=0;j<this.obstaclearray.length;j++){
	  
	   if(this.obstaclearray[j+1]){
	   if(this.calculateDistance(this.obstaclearray[j+1],true)<this.calculateDistance(obstacle)){
	     obstacle=this.obstaclearray[j+1]
	   }
	   }
	}
	 return obstacle
	 }
	
	 //updating--计算障碍中心到head的向量
	 updatingcalculateobstaclematrix(a){
	
	  let obstacle = this.findMostcloseobstacle();
	
	     this.obstaclematrix = {
		  x:(this.headposition.x - obstacle.x),
		  y:(this.headposition.y - obstacle.y)
		 };
		 this.avoidforce = {
		  x:this.MAX_AVOID_FORCE*(this.head.x+this.obstaclematrix.x),
		  y:this.MAX_AVOID_FORCE*(this.head.x+this.obstaclematrix.y)
		 }
		
		
		 if((this.calculateDistance(obstacle,false)>obstacle.r)&&((obstacle.x-this.x)**2+(obstacle.y-this.y)**2>=(this.r+obstacle.r)**2)){
		 
		   this.avoidforce={
		   x:0,
		   y:0
		   }
		   
		 }else{
		
		 }
	//	 console.log(this.avoidforce.x,this.avoidforce.y)
	 }
	 //实时更新--head,head position
	 updating(){
	 
	 this.head = {
	    x:this.velocity.x*this.MAX_SEE_AHEAD,
		y:this.velocity.y*this.MAX_SEE_AHEAD
	   };
	   const cos = this.head.x/(this.head.x**2+this.head.y**2)**0.5;
	   const sin = this.head.y/(this.head.x**2+this.head.y**2)**0.5;
	   this.headposition = {
	    x:this.x+this.head.x,
		y:this.y+this.head.y
	   };
	   this.headpositionleft= {
	    x:this.headposition.x - this.r*sin,
		y:this.headposition.y + this.r*cos
	   
	   }
	    this.headpositionright= {
	    x:this.headposition.x + this.r*sin,
		y:this.headposition.y - this.r*cos
	   
	   }
	 }
	  //位置检测函数 如果两者的距离小于了两者圆心的距离则迅速让其分离
	 positionTestfunc(){
	 let obstacle = this.findMostcloseobstacle();
	 if((obstacle.x-this.x)**2+(obstacle.y-this.y)**2<(this.r+obstacle.r)**2){
	   let overlapdistance = ((((obstacle.x-this.x)**2+(obstacle.y-this.y)**2)**0.5-(this.r+obstacle.r))**2)**0.5,
	       overlapobj = {
		    x: this.x - obstacle.x,
			y:this.y - obstacle.y
		   },
		  
		   cos = overlapobj.x/((overlapobj.x)**2+(overlapobj.y)**2)**0.5,
	       sin = overlapobj.y/((overlapobj.x)**2+(overlapobj.y)**2)**0.5;
	   this.x = this.x+(overlapdistance)*cos
	   this.y = this.y + (overlapdistance)*sin
	       
	   
	 }
	 }
	 //实时更新速度
	 updatingVelocity(){
	 let obstacle = this.findMostcloseobstacle();
	 
	 let acceleration = {
	   x:this.avoidforce.x/this.mass?this.avoidforce.x/this.mass:0,
	   y:this.avoidforce.y/this.mass?this.avoidforce.y/this.mass:0
	 }
	let directionofmiles = {
	x:obstacle.x-this.x,
	y:obstacle.y-this.y
	}
	
	  if((!acceleration.x)&&(!acceleration.y)){
	console.log(directionofmiles.x/acceleration.x,directionofmiles.y/acceleration.y);  
	  }else{
	  //
	     let maxvalueX = Math.max(obstacle.velocity.x,this.velocity.x),
		     maxvalueY = Math.max(obstacle.velocity.y,this.velocity.y),
	        velocityall = (maxvalueX**2+maxvalueY**2)**0.5,
		  //   velocityall = (this.velocity.x**2+this.velocity.y**2)**0.5,
	         xvelocity = acceleration.x/(acceleration.x**2+acceleration.y**2)**0.5,
		     yvelocity = acceleration.y/(acceleration.x**2+acceleration.y**2)**0.5;
		   
		   
		   this.velocity = {
		   x:velocityall*xvelocity+id*2,
		 //  x:this.velocity.x+acceleration.x*this.dt,
		   //y:this.velocity.y+acceleration.y*this.dt
		   y:velocityall*yvelocity+id*2
		   };
		   if(this.movingtimer){
		   setTimeout(()=>{
		   clearInterval(this.movingtimer);
		   let e = {
		   pageX:this.destination.x,
		   pageY:this.destination.y
		   }
		   let cos = (e.pageX - this.x)/((e.pageX - this.x)**2+(e.pageY - this.y)**2)**0.5;
let sin = (e.pageY - this.y)/((e.pageX - this.x)**2+(e.pageY - this.y)**2)**0.5;
 this.velocity = {
 x:cos*30,
 y: sin*30,
 }
 this.positionTestfunc()
		   this.motivateForce();
		   },16.6)
		   
		   }
	  }
	
	  
	 console.log(this.velocity)
	 }
	 //实时更新位移
	 updatingDisplacement(){
	 //如果快到边边了 返回去
	 if(this.x>700||this.y>700||this.x<0||this.y<0){
	 this.velocity = {
	 
	 x:-this.velocity.x,
	 y:-this.velocity.y
	 }
	 
	 }
	  let ds = {
	    x:this.velocity.x*this.dt,
		y:this.velocity.y*this.dt
	  }
	  this.x+=ds.x;
	  this.y+=ds.y
	 }
	 
	 repaint(){
	
	   context.clearRect(this.x-this.r-8,this.y-this.r-8,this.r*2+14,this.r*2+14);  
	   context.beginPath();
	    context.arc(this.x,this.y,this.r,0,2*Math.PI);
		context.stroke();
	 }
  }
  let obstacleCircle1 = new Circle(100,175,20)
  let obstacleCircle2 = new Circle(100,475,20)
  let obstacleCircle3 = new Circle(150,475,20)
   context.stroke();
   context.beginPath();
   let movingCircle = new Circle(150,175,20);
   
     context.stroke();
	  movingCircle.injectObstacles(obstacleCircle1);
	  movingCircle.injectObstacles(obstacleCircle2);
	   movingCircle.injectObstacles(obstacleCircle3);
	  obstacleCircle1.injectObstacles(movingCircle);
	  obstacleCircle1.injectObstacles(obstacleCircle2);
	   obstacleCircle1.injectObstacles(obstacleCircle3);
	  obstacleCircle2.injectObstacles(obstacleCircle1);
	  obstacleCircle2.injectObstacles(movingCircle);
	   obstacleCircle2.injectObstacles(obstacleCircle3);
	   
	    obstacleCircle3.injectObstacles(obstacleCircle1);
	  obstacleCircle3.injectObstacles(movingCircle);
	   obstacleCircle3.injectObstacles(obstacleCircle2);
	 // movingCircle.updating();
	  movingCircle.motivateForce()
	  obstacleCircle1.velocity = {
	  x:0,
	  y:60
	  }
      obstacleCircle1.destination = {
	   x:obstacleCircle1.x,
	  y:obstacleCircle1.y + 300
	  }
	  movingCircle.destination = {
	   x:movingCircle.x,
	  y:movingCircle.y + 300
	  }
	  obstacleCircle2.velocity = {
	  x:-0,
	  y:-60
	  }
	  obstacleCircle2.destination={
	  x:obstacleCircle2.x,
	  y:obstacleCircle2.y - 300
	  }
	  obstacleCircle3.velocity = {
	  x:0,
	  y:-60
	  }
	   obstacleCircle3.destination = {
	   x:obstacleCircle3.x,
	  y:obstacleCircle3.y - 300
	  }
	   obstacleCircle2.motivateForce();
	obstacleCircle1.motivateForce()
obstacleCircle3.motivateForce()
}

</script>
</html>
