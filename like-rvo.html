<!DOCTYPE html>
<html>
<style>
.container{
  width:100vw;
  overflow:scroll;
  border:1px solid red;
  display:flex;
  font-size:58px;
  position:relative;
}
.items{
 padding:0 20px;
  text-align:center;
  border-right:1px solid red;
  flex-shrink:0
}
.greenbar{
  text-align:center;
   background:green;
   top:70px;
   width:100px;
    position:absolute;
	height:5px;
	transition: left 0.2s ease;
}

</style>
<body >
  <canvas width=700 height=700 id="canvas"></canvas>
</body>
<script>
window.onload = function () {
    let obstaclearray = []
    let canvas = document.getElementById('canvas');
    canvas.onclick = function (e) {
        //console.log(e.pageX,e.pageY);
      //  movingCircle.avoidforce = {
      //      x: 0,
       //     y: 0
     //   }
        change(movingCircle, e);
        change(obstacleCircle1, e);
        change(obstacleCircle2, e)
        change(obstacleCircle3, e)
    }
    function change(obj, e) {
        let cos = (e.pageX - obj.x) / ((e.pageX - obj.x) ** 2 + (e.pageY - obj.y) ** 2) ** 0.5;
        let sin = (e.pageY - obj.y) / ((e.pageX - obj.x) ** 2 + (e.pageY - obj.y) ** 2) ** 0.5;
        obj.velocity = {
            x: cos * 30,
            y: sin * 30,
        }
        obj.destination = {
            x: e.pageX,
            y: e.pageY
        }
    }
    let context = canvas.getContext("2d");
    context.beginPath();
    id = 1;
    class Circle {
        constructor(x, y, r) {
            this.id = ++id
                this.x = x;
            this.mass = 2
                this.y = y;
            this.r = r;
            this.inaviodingmode = {
                time: 0,
                start: false,
                end: true
            }
            this.dt = 0.02;
            // obstaclearray=[]
            this.obstaclematrix = {
                x: 0,
                y: 0
            }
            this.avoidforce = {
                x: 0,
                y: 0
            }
            this.gravityforce = {
                x: 0,
                y: 0
            }
            this.seekforce = {
			 x:0,
			 y:0
			}
            this.velocity = {
                x: 0,
                y: 60
            }
            this.destination = {
                x: 400,
                y: 400
            }
            this.MAX_SEE_AHEAD = 10;
            this.MAX_AVOID_FORCE = 40
                this.MAX_SPEED = 40
				this.MAX_SEEK_FORCE = 40;
                this.movingtimer = null
                this.paint();
            obstaclearray.push(this)
        }
        injectObstacles(obstacle) {
            // obstaclearray.push(obstacle)
        }
        paint() {
            context.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
        }
        motivateForce() {
            this.movingtimer = setInterval(() => {
                    this.x += this.dt * this.velocity.x;
                    this.y += this.dt * this.velocity.y;
                    this.updating();

                    this.updatingcalculateobstaclematrix(obstaclearray[0]);
                    this.updatingVelocity();
                    this.updatingDisplacement();
                    this.repaint()
                }, 16.6)

        }

        //计算最近的距离
        calculateDistance(obstacle, usemiddle = false) {
            if (!usemiddle) {
                let left = (((this.headpositionleft.x - obstacle.x) ** 2 + (this.headpositionleft.y - obstacle.y) ** 2)) ** 0.5,
                right = (((this.headpositionright.x - obstacle.x) ** 2 + (this.headpositionright.y - obstacle.y) ** 2)) ** 0.5

                return left <= right ? left : right
            } else {
                return (((this.headposition.x - obstacle.x) ** 2 + (this.headposition.y - obstacle.y) ** 2)) ** 0.5
            }

        }
        //计算最近的障碍物
        findMostcloseobstacle() {
            let tempobstaclearray = JSON.parse(JSON.stringify(obstaclearray));
         
            for (let j = 0; j < tempobstaclearray.length; j++) {
                if (tempobstaclearray[j].id == this.id) {
                    tempobstaclearray.splice(j, 1);
                    j--
                }
            }
            let obstacle = tempobstaclearray[0];

            for (let j = 0; j < tempobstaclearray.length; j++) {
                if (tempobstaclearray[j].id != this.id) {
                    if (tempobstaclearray[j + 1]) {
                        if (this.calculateDistance(tempobstaclearray[j + 1], true) < this.calculateDistance(obstacle)) {
                            obstacle = tempobstaclearray[j + 1]
                        }
                    }
                }

            }
            return obstacle
        }
        //计算-seek
         calculateSeekforce(){
		 let destination = {
			x:this.destination.x - this.x,
			y:this.destination.y - this.y
			}
		
			let cons = destination.x/((destination.x)**2+(destination.y)**2)**0.5;
			let sins = destination.y/((destination.x)**2+(destination.y)**2)**0.5;
			let currentspendlength = ((destination.x)**2+(destination.y)**2)**0.5;
		  
		  
		  //假设 seekforce恒定？
		  let destinationvelocity ={
			 x: cons*this.MAX_SPEED,
			 y:sins*this.MAX_SPEED
			
			}
		  
			//假设朝向终点的速度与物体到终点的长度成正比
			this.seekforce = {
			  x:destination.x - this.velocity.x,
			  y:destination.y - this.velocity.y,
			}
			if(this.id==2){
			 console.log(this.seekforce.x,this.seekforce.y)
			}
		 
		 }
		 //就算当两者正碰，或者类似于正碰的时候 此时应对应的给两者以垂直于圆心的相等反向的排斥力?
		 calculateIffrontcollision(obstacle){
		    
		 }
		 //计算-obstacle avoidance
		 calculateObstacleavoidance(obstacle){
		 
		  this.obstaclematrix = {
                x: (this.headposition.x - obstacle.x),
                y: (this.headposition.y - obstacle.y)
            };
		 }
		 
        //updating--计算障碍中心到head的向量--障碍物产生的力obstacle avoidance
        updatingcalculateobstaclematrix(a) {

            let obstacle = this.findMostcloseobstacle();
            //	console.log(obstacle)

            this.calculateObstacleavoidance(obstacle);
			
			this.calculateSeekforce();
			
            this.avoidforce = {
                x: this.MAX_AVOID_FORCE * (this.obstaclematrix.x),
                y: this.MAX_AVOID_FORCE * (this.obstaclematrix.y)
            }

            if ((this.calculateDistance(obstacle, false) > obstacle.r) && ((obstacle.x - this.x) ** 2 + (obstacle.y - this.y) ** 2 >= (this.r + obstacle.r) ** 2)) {

                this.avoidforce = {
                    x: 0,
                    y: 0
                }

            } else {}
            //	 console.log(this.avoidforce.x,this.avoidforce.y)
        }
        //实时更新--head,head position
        updating() {
            //	 console.log(this.id,this.velocity.x,this.velocity.y)
            this.head = {
                x: this.velocity.x * this.MAX_SEE_AHEAD,
                y: this.velocity.y * this.MAX_SEE_AHEAD
            };
            const cos = this.head.x / (this.head.x ** 2 + this.head.y ** 2) ** 0.5;
            const sin = this.head.y / (this.head.x ** 2 + this.head.y ** 2) ** 0.5;
            this.headposition = {
                x: this.x + this.head.x,
                y: this.y + this.head.y
            };
            this.headpositionleft = {
                x: this.headposition.x - this.r * sin,
                y: this.headposition.y + this.r * cos

            }
            this.headpositionright = {
                x: this.headposition.x + this.r * sin,
                y: this.headposition.y - this.r * cos

            }
        }
        //位置检测函数 如果两者的距离小于了两者圆心的距离则迅速让其分离
        positionTestfunc() {
            let obstacle = this.findMostcloseobstacle();
            if ((obstacle.x - this.x) ** 2 + (obstacle.y - this.y) ** 2 < (this.r + obstacle.r) ** 2) {
                let overlapdistance = ((((obstacle.x - this.x) ** 2 + (obstacle.y - this.y) ** 2) ** 0.5 - (this.r + obstacle.r)) ** 2) ** 0.5,
                overlapobj = {
                    x: this.x - obstacle.x,
                    y: this.y - obstacle.y
                },

                cos = overlapobj.x / ((overlapobj.x) ** 2 + (overlapobj.y) ** 2) ** 0.5,
                sin = overlapobj.y / ((overlapobj.x) ** 2 + (overlapobj.y) ** 2) ** 0.5;
                this.x = this.x + (overlapdistance) * cos
                    this.y = this.y + (overlapdistance) * sin

            }
        }
        //实时更新速度
        updatingVelocity() {
            let obstacle = this.findMostcloseobstacle();

            let acceleration = {
                x:( this.seekforce.x+this.avoidforce.x) / this.mass ? (this.seekforce.x+this.avoidforce.x) / this.mass : 0,
                y: (this.seekforce.y+this.avoidforce.y) / this.mass ? (this.seekforce.y+this.avoidforce.y) / this.mass : 0
            }
            let directionofmiles = {
                x: obstacle.x - this.x,
                y: obstacle.y - this.y
            }
                let xvelocity = acceleration.x / (acceleration.x ** 2 + acceleration.y ** 2) ** 0.5,
                    yvelocity = acceleration.y / (acceleration.x ** 2 + acceleration.y ** 2) ** 0.5;
                  this.velocity = {
                  //  x: velocityall * xvelocity + id * 2,
                      x:this.velocity.x+acceleration.x*this.dt,
                    y:this.velocity.y+acceleration.y*this.dt
                    //y: velocityall * yvelocity + id * 2
                };
				let all = ((this.velocity.x)**2+this.velocity.y**2)**0.5;
					  if(all>this.MAX_SPEED){
					   let cosa = this.velocity.x/((this.velocity.x)**2+this.velocity.y**2)**0.5;
					let sina = this.velocity.y/((this.velocity.x)**2+this.velocity.y**2)**0.5
					this.velocity = {
					  x:this.MAX_SPEED*cosa,
					  y:this.MAX_SPEED*sina
					}
					  }
					  if(this.id==2){
					  	  console.log(this.velocity.x,this.velocity.y,'速度')
					  }
				
				//	  clearInterval(this.movingtimer)
           this.positionTestfunc()
           // this.motivateForce();

            //	 console.log(this.velocity)
        }
        //实时更新位移
        updatingDisplacement() {
            //如果快到边边了 返回去
            if (this.x > 700 || this.y > 700 || this.x < 0 || this.y < 0) {
                this.velocity = {

                    x: -this.velocity.x,
                    y: -this.velocity.y
                }

            }
            let ds = {
                x: this.velocity.x * this.dt,
                y: this.velocity.y * this.dt
            }
            this.x += ds.x;
            this.y += ds.y
        }

        repaint() {

            context.clearRect(this.x - this.r - 8, this.y - this.r - 8, this.r * 2 + 14, this.r * 2 + 14);
             if(this.id==2){
			context.strokeStyle = "red"
			}else{
			context.strokeStyle = "green"
			}

            context.beginPath();
            context.arc(this.x, this.y, this.r, 0, 2 * Math.PI);
            context.stroke();
        }
    }
    let obstacleCircle1 = new Circle(100+Math.random(), 175+Math.random(), 20)
        let obstacleCircle2 = new Circle(100+Math.random(), 475+Math.random(), 20)
        let obstacleCircle3 = new Circle(150+Math.random(), 475+Math.random(), 20)
        context.stroke();
    context.beginPath();
	
    let movingCircle = new Circle(150+Math.random(), 175+Math.random(), 20);

    context.stroke();

    obstacleCircle1.velocity = {
        x: 0,
        y: 60
    }
    obstacleCircle1.destination = {
        x: obstacleCircle1.x+300,
        y: obstacleCircle1.y + 300
    }
    movingCircle.destination = {
        x: movingCircle.x,
       y: movingCircle.y + 300
   }

    obstacleCircle2.velocity = {
        x: -0,
        y: -60
    }
    obstacleCircle2.destination = {
        x: obstacleCircle2.x,
        y: obstacleCircle2.y - 300
    }

    obstacleCircle3.velocity = {
        x: 0,
        y: -60
    }
   obstacleCircle3.destination = {
        x: obstacleCircle3.x,
       y: obstacleCircle3.y - 300
    }

    obstacleCircle2.motivateForce();
    obstacleCircle1.motivateForce()
    obstacleCircle3.motivateForce()
   movingCircle.motivateForce()
}
</script>
</html>
